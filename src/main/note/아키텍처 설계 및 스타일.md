## ⭕ 이벤트 중심 아키텍처 (EDA, Event-Driven Architecture)
시스템 내에서 발생하는 이벤트의 생성, 감지, 소비, 그리고 이에 대한 반응을 핵심 원리로 삼는 아키텍처 패턴

### ◉ EDA의 주요 구성 요소와 작동 방식
- 이벤트 생성자 (Event Producer/Publisher): 시스템 내에서 특정 사건이 발생했을 때(예: 주문 생성) 해당 이벤트를 만들어서 발행(Publish)하는 컴포넌트이다.
- 이벤트 채널 (Event Channel/Broker/Bus): 생성자가 발행한 이벤트를 수신하여, 해당 이벤트를 구독(Subscribe)하고 있는 소비자들에게 전달하는 중간 매개체이다. (예: Kafka, RabbitMQ, AWS SQS 등)
- 이벤트 소비자 (Event Consumer/Subscriber): 특정 종류의 이벤트에 관심을 가지고 구독하다가 이벤트 채널로부터 이벤트를 전달받으면 그에 맞는 작업(예: 데이터베이스 업데이트, 알림 발송, 다른 시스템 호출 등)을 수행하는 컴포넌트이다.

### ◉ EDA의 핵심 특징 및 장점
- 느슨한 결합: 이벤트 생성자와 소비자가 서로를 직접 알 필요 없이 이벤트 채널을 통해 상호작용한다. 덕분에 각 컴포넌트를 독립적으로 개발, 배포, 수정, 확장하기 용이하다.
- 비동기 처리: 이벤트 생성자는 이벤트를 발행한 후 소비자의 처리 완료를 기다리지 않아도 되므로 시스템 응답성이 향상될 수 있다.
- 확장성: 특정 이벤트 처리에 부하가 몰리면 해당 이벤트를 처리하는 소비자 컴포넌트만 독립적으로 확장할 수 있다. 새로운 기능이 필요할 때 기존 이벤트를 구독하는 새로운 소비자를 추가하기 쉽다.
- 탄력성: 특정 소비자에 장애가 발생하더라도 다른 소비자나 이벤트 생성자에게 미치는 영향이 적다.

### ◉ EDA에도 단점 및 고려사항
- 이벤트 순서 보장 문제: 여러 이벤트가 발생했을 때 소비자가 이벤트를 발생 순서대로 처리하도록 보장하는 것이 어려울 수 있다.
  - 예를 들어, 주문 생성 이벤트와 결제 완료 이벤트가 발생했을 때, 소비자가 결제 완료 이벤트를 먼저 처리하면 데이터 불일치가 발생할 수 있다.
  - 이런 문제를 해결하기 위해 DDD의 애그리거트 개념을 활용하여 이벤트를 그룹화하거나, 이벤트의 순서를 보장하는 추가적인 메커니즘을 도입할 수 있다.
- 데이터 일관성 문제: 여러 소비자가 동일한 이벤트에 반응할 때 전체 시스템의 데이터 일관성을 유지하기 위한 설계가 복잡할 수 있다.
- 이벤트 발행자-소비자 간 결합도 문제: 명시적인 호출 관계는 없지만 소비자가 이벤트의 특정 데이터 구조에 의존하게 되면 암묵적인 결합이 발생할 수 있다.

### ◉ 애그리거트란?
도메인 주도 설계(DDD, Domain-Driven Design)의 핵심적인 개념으로 서로 밀접하게 관련된 데이터(도메인 객체)들의 묶음을 하나의 큰 단위(덩어리)로 취급하는 것을 의미한다. 이 덩어리 전체가 데이터 변경 및 관리의 기본 단위가 된다.

#### ◉ 애그리거트의 주요 특징
- 단일 단위 취급: 이 객체 묶음 전체가 데이터 변경 및 관리(생성, 조회, 수정, 삭제)의 기본 단위가 된다.
- 일관성 경계: 애그리거트는 데이터의 일관성이 유지되어야 하는 범위를 정의한다. 애그리거트 내의 객체들은 항상 함께 일관된 상태를 가져야 한다.
- 애그리거트 루트: 각 애그리거트에는 이 묶음을 대표하고 외부와의 상호작용 지점 역할을 하는 루트 객체가 반드시 하나 존재한다.
- 접근 제어: 애그리거트 외부에서는 오직 애그리거트 루트를 통해서만 내부의 다른 객체들에 접근하고 상태를 변경할 수 있다.

#### ✦ 애그리거트의 장점
- 데이터 일관성 보장
  - 애그리거트는 관련된 객체들이 항상 유효한 상태로 함께 유지되도록 하는 '일관성 경계' 역할을 한다.
  - 애그리거트 루트를 통해서만 내부 객체에 접근할 수 있으므로, 데이터의 일관성을 보장하기 쉽다.
  - 나의 트랜잭션으로 처리하여 데이터 정합성을 보장한다.
- 모델 복잡성 관리
  - 복잡한 도메인을 연관된 객체들의 묶음인 애그리거트 단위로 나누어 생각함으로써 전체 모델을 이해하고 관리하기 쉽게 만든다.
- 명확한 소유권 및 경계 정의
  - 애그리거트 루트는 해당 애그리거트 내부에 포함된 모든 객체에 대한 소유권을 가진다.
  - 에그리거트 경계는 어떤 객체들이 강하게 연관되어 함꼐 변경되어야 하는지를 명확히 정의한다.
- 캡슐화 강화
  - 애그리거트 내부의 복잡한 구조나 상세 로직은 외부로부터 숨겨진다.
  - 외부에서는 오직 애그리거트 루트가 제공하는 메서드를 통해서만 상호작용하므로 내부 구현 변경이 외부에 미치는 영향을 최소화할 수 있다.

#### ✦ 애그리거트 예시
- 애그리거트 루트: 주문 객체
  - 속성: 주문 ID, 고객 ID, 주문 상태(결제 대기, 배송 중, 완료 등), 총 주문 금액, 주문 일시
- 내부 객체
  - 주문 항목: 상품 ID, 수량, 개별 가격
  - 배송 주소: 수령인, 주소, 연락처
  - 결제 정보 결제 수단, 결제 상태
- 경계와 규칙
  - 주문 항목을 추가/삭제하거나 배송지를 변경하는 작업은 반드시 주문 루트 객체를 통해서만 가능하다.
  - 주문 객체는 주문 항목이 변경될 때마다 총 주문 금액을 재계산하여 내부 일관성을 유지한다.
  - "배송 시작됨" 상태의 주문에는 항목을 추가할 수 없다는 비즈니스 규칙을 주문 루트 객체가 검증하고 강제한다.
  - 이 모든 변경 사항은 하나의 트랜잭션으로 처리되어야 한다.

#### ✦ 애그리거트 단점
- 성능 저하: 애그리거트가 너무 커지면 데이터베이스 쿼리가 복잡해지고 성능이 저하될 수 있다.
- 복잡한 트랜잭션 관리: 애그리거트 내의 모든 객체가 일관성을 유지해야 하므로, 트랜잭션 관리가 복잡해질 수 있다.
- 유연성 저하: 애그리거트의 경계가 너무 엄격하면 도메인 모델의 유연성이 떨어질 수 있다. 예를 들어, 애그리거트 내의 객체들이 서로 강하게 결합되어 있으면, 변경이 필요할 때 전체 애그리거트를 수정해야 할 수도 있다.
- 과도한 캡슐화: 애그리거트가 너무 많은 책임을 지게 되면, 애그리거트 루트 객체가 비대해지고 복잡해질 수 있다. 이로 인해 코드 가독성이 떨어지고 유지보수가 어려워질 수 있다.

## ⭕ CQRS (Command Query Responsibility Segregation)
데이터 상태를 변경하는 책임(Command, 명령)과 데이터 상태를 조회하는 책임(Query, 조회)을 서로 분리하는 아키텍처 설계 패턴

### ◉ CQRS의 주요 특징
- 명령과 조회의 분리: 데이터 상태를 변경하는 명령과 데이터를 조회하는 쿼리를 서로 다른 모델로 분리하여 처리한다.
- 각각의 모델 최적화: 명령과 조회 모델을 각각의 요구사항에 맞게 최적화할 수 있다. 예를 들어, 명령 모델은 데이터 일관성을 중시하고 조회 모델은 성능을 중시할 수 있다.
- 데이터 동기화: 명령 모델과 조회 모델 간의 데이터 동기화가 필요하다. 이를 위해 이벤트 소싱이나 메시지 큐를 사용할 수 있다.

### ◉ CQRS의 장점
- 성능 최적화: 읽기/쓰기 작업 부하 특성에 맞춰 각 모델을 독립적으로 최적화하고 확장할 수 있다. (예: 읽기 작업이 훨씬 많으면 읽기 모델만 확장)
- 모델 단순화: 각 모델이 하나의 책임(쓰기 또는 읽기)에만 집중하므로 설계가 더 명확해질 수 있다.
- 유연성 및 확장성: 새로운 조회 요구사항이 생기면 기존 시스템에 영향을 덜 주면서 새로운 읽기 모델을 추가하기 용이하다.

### ◉ CQRS의 단점
- 복잡성 증가: 전통적인 CRUD 방식보다 설계 및 구현이 복잡하다. 고려해야 할 요소(모델 분리, 데이터 동기화 등)가 늘어난다.
- 최종 일관성: 데이터 동기화 방식에 따라 읽기 모델의 데이터가 최신 상태가 아닐 수 있다. 실시간 데이터 정합성이 매우 중요한 시스템에는 부적합할 수 있다.
- 코드 중복 가능성: 쓰기 모델과 읽기 모델 간에 일부 데이터 구조나 로직이 중복될 수 있다.

## ⭕ 도메인 주도 설계 (DDD, Domain-Driven Design)
소프트웨어 개발의 복잡성을 관리하기 위해 핵심 비즈니스 영역인 도메인 자체에 집중하고 도메인 모델을 중심으로 소프트웨어를 설계하고 구현해나가는 개발 방법론이다.

### ◉ DDD 특징
- 핵심 도메인 집중: 비즈니스 가치가 가장 높은 핵심 도메인을 식별하고 여기에 개발 노력을 집중한다.
- 모델 주도 설계: 도메인에 대한 깊은 이해를 바탕으로 생성된 '도메인 모델'이 분석, 설계, 구현 전반에 걸쳐 중심적인 역할을 한다.
- 보편 언어 사용: 도메인 전문가와 개발팀 모두가 동의하고 사용하는, 도메인 모델에 기반한 공통된 용어 체계를 구축하고 모든 의사소통과 코드에 일관되게 적용한다.
- 경계 컨텍스트 분리: 거대하고 복잡한 도메인을 논리적으로 독립적인 여러 개의 '경계 컨텍스트'로 나누어 관리한다. 각 컨텍스트는 자체적인 모델과 보편 언어를 가진다.

### ◉ 주요 개념
- 전략적 설계 
  - 도메인: 소프트웨어가 다루는 비즈니스 영역, 문제 공간. 
  - 도메인 모델: 특정 도메인의 지식(개념, 규칙, 관계)을 선택적으로 추상화하여 표현한 것. 
  - 보편 언어: 도메인 모델을 기반으로 팀 내 모든 구성원이 사용하는 단일화된 언어. 
  - 경계 컨텍스트: 특정 도메인 모델이 일관성을 가지는 명시적인 경계. 모델과 언어의 독립성을 보장하는 단위. 
  - 컨텍스트 맵: 여러 경계 컨텍스트 간의 관계와 상호작용 방식을 보여주는 지도.
- 전술적 설계
- 엔티티: 고유한 식별자(ID)를 가지며 시간이 지나도 연속성을 유지하는 객체 (예: 고객, 주문).
- 값 객체: 식별자 없이 속성 값 자체로 의미를 가지는 불변 객체 (예: 주소, 금액). 속성이 같으면 같은 객체로 취급한다.
- 애그리거트: 관련된 엔티티와 값 객체들의 묶음으로, 데이터 변경 및 일관성 유지의 단위. 하나의 루트를 가진다.
  - 애그리거트 루트: 애그리거트의 대표 엔티티로, 외부에서 애그리거트에 접근하는 유일한 진입점. 애그리거트 내부의 일관성을 책임진다.
- 리포지토리: 애그리거트의 영속성(저장, 조회 등)을 처리하는 인터페이스. 도메인 계층과 인프라 계층(DB 등)을 분리한다.
- 도메인 서비스: 특정 엔티티나 값 객체에 속하지 않는 도메인 로직(여러 도메인 객체에 걸친 작업 등)을 수행하는 객체. 주로 상태 없이 행동만 가진다.
- 도메인 이벤트: 도메인 내에서 발생한 의미 있는 사건을 나타내는 객체. 애그리거트나 컨텍스트 간의 상태 변경 알림 및 연동에 사용된다.

### ◉ 장점
- 의사소통 향상: 보편 언어를 통해 도메인 전문가와 개발자 간의 오해를 줄이고 명확한 소통을 가능하게 한다.
- 비즈니스-코드 일치도 향상: 소프트웨어 코드가 실제 비즈니스 도메인의 개념과 규칙을 더 정확하게 반영하게 된다.
- 유연성 및 유지보수성 증대: 명확한 경계 컨텍스트 분리와 잘 정의된 도메인 모델은 시스템을 더 모듈화하고 변경에 유연하며 유지보수하기 쉽게 만든다.
- 복잡성 관리 용이: 핵심 도메인에 집중하고 문제를 작은 컨텍스트로 분해하여 복잡성을 효과적으로 관리할 수 있다.
- 비즈니스 가치 집중: 개발 노력이 비즈니스적으로 가장 중요한 부분에 집중되어 가치 전달을 극대화한다.
